package lattice;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

/**
 * @author Zheng ZHANG
 */



import exploratoryRDFAnalytics.StatementGenerator;

public class Lattice {
	
	private HashMap<Integer, ArrayList<Atom>> atoms = new HashMap<Integer, ArrayList<Atom>>();
	// Generated by information of GROUP_BY_PROPERTIES_RESULT_FILE, and ordered as in this file.
	private ArrayList<String> propertiesNames = new ArrayList<String>();
	private ArrayList<String> propertiesShorterNames = new ArrayList<String>();
	private int propertyQuantity;
	
	static int nodeNumber = 0;
	
	public Lattice(String filePath) throws FileNotFoundException, IOException, GroupByPropertiesResultFileContentWrongException {
		generateAtoms_byReadingGroupByPropertiesResultFile(filePath);
		linkAtoms();
	}
	
	
	public void writeJSONFile(String filePath) throws IOException {
		 File writename = new File(filePath); 
         writename.createNewFile(); 
         BufferedWriter out = new BufferedWriter(new FileWriter(writename));  
         
         StringBuilder nodes = new StringBuilder();
         StringBuilder links = new StringBuilder();        
         nodes.append("\t\"nodes\":[\n");
         links.append("\t\"links\":[\n");
         
         int nodeNumber = 0;
         // Go through atoms from level 1(one property) to the bottom level(all properties). 
         for(int i=0; i<atoms.size(); i++) {
        	 ArrayList<Atom> atomsInOneLevel = atoms.get(i);
        	 for(Atom a: atomsInOneLevel) {
        		 if(a.getCount() > lattice.GlobalSettings.MINIMUM_COUNT_NUMBER) {
					nodes.append("\n");
					nodes.append(String.format("\t\t{\"name\":\"%s\",\"group\":%d,\"count\":%d},", a.toString(), a.getLevel(), a.getCount()));
					a.setNodeNumber(nodeNumber++);

					// Starting from level 1.
					if (i != 0) {
						for (Atom parent : a.getParents()) {
							links.append("\n");
							links.append(String.format("\t\t{\"source\":%d,\"target\":%d,\"value\":%d},", a.getNodeNumber(), parent.getNodeNumber(), 5));
						}
					}
        		 }
        	 } 
         }
         
         nodes.deleteCharAt(nodes.length()-1);
         nodes.append("\n\t],");
         links.deleteCharAt(links.length()-1);
         links.append("\n\t]");
         out.write("{\n" + nodes + "\n" + links + "\n}");
         
         out.flush(); 
         out.close();  
	}
	
	
	/* 
	 * Building a lattice by starting from a specific atom.
	 * e.g. INPUT: 	Atom(creator, year): level 2
	 * 		OUTPUT: Atom(creator, year): level 2 
	 * 				& Atom(creator): level 1 
	 * 				& Atom(year): level 1 
	 * 				& Atom(all): level 0
	 */
	public void writeJSONFile(String filePath, Atom atom) throws IOException {
		int index = this.atoms.get(atom.getPropertyCombination().size()).indexOf(atom);
		atom = this.atoms.get(atom.getPropertyCombination().size()).get(index);
		
		File writename = new File(filePath);
		writename.createNewFile();
		BufferedWriter out = new BufferedWriter(new FileWriter(writename));

		StringBuilder nodes = new StringBuilder();
		StringBuilder links = new StringBuilder();
		nodes.append("\t\"nodes\":[\n");
		links.append("\t\"links\":[\n");
		
		connectToParents(atom, nodes, links);
		
		nodes.deleteCharAt(nodes.length() - 1);
		nodes.append("\n\t],");
		links.deleteCharAt(links.length() - 1);
		links.append("\n\t]");
		out.write("{\n" + nodes + "\n" + links + "\n}");

		out.flush();
		out.close();
	}
	
	
	private void connectToParents(Atom child, StringBuilder nodes, StringBuilder links) {
		if(!child.isVisited()) {
			nodes.append("\n");
			nodes.append(String.format("\t\t{\"name\":\"%s\",\"group\":%d,\"count\":%d},", child.toString(), child.getLevel(), child.getCount()));
			if(!child.hasSetNodeNumber()) {
				child.setNodeNumber(nodeNumber++);
			}
			child.setVisited(true);
		}
		if(child.hasParents()) {
			for (Atom parent : child.getParents()) {
				if(!parent.hasSetNodeNumber()) {
					parent.setNodeNumber(nodeNumber++);
				}
				links.append("\n");
				links.append(String.format("\t\t{\"source\":%d,\"target\":%d,\"value\":%d},", child.getNodeNumber(), parent.getNodeNumber(), 5));
				connectToParents(parent, nodes, links);
			}
		}
	}
	
	
	@Override
	public String toString() {
		StringBuilder result = new StringBuilder();
		for (Map.Entry<Integer, ArrayList<Atom>> entry : atoms.entrySet()) {
		    Integer key = entry.getKey();
		    ArrayList<Atom> value = entry.getValue();
		    result.append("************************** " + key + " **************************" + "\n");
		    Iterator<Atom> it = value.iterator();
		    while(it.hasNext()) {
		    	Atom atom = it.next();
		    	result.append(atom + "\t");
		    }
		    result.append("\n" + "-------------------------------------------------------" + "\n" + "\n");
		}
		return result.toString();
	}
	
	
	private void generateAtoms_byReadingGroupByPropertiesResultFile(String filePath) throws FileNotFoundException, IOException, GroupByPropertiesResultFileContentWrongException {
		try (BufferedReader br = new BufferedReader(new FileReader(filePath))) {
			// Get property information.
			String line = br.readLine();
			propertyQuantity = Integer.parseInt(line);
			for (int i = 0; i < propertyQuantity; i++) {
				line = br.readLine();
				propertiesNames.add(line.split(":\t")[1]);
			}
			initializePropertiesShorterNames();

			// Jump two useless lines of the file.
			br.readLine();
			br.readLine();

			// Get property combination information.
			line = br.readLine();
			while (line != null) {
				constructAtomByPropertyCombinationInformation(line);
				line = br.readLine();
			}
		}
	}
	
	
	/*
	 * INPUT: e.g. "t	f	t	 2"
	 */
	private void constructAtomByPropertyCombinationInformation(String line) throws GroupByPropertiesResultFileContentWrongException {
		// e.g. if input is "t	f	t	 2", the allCombinationsResource should be [1, 3] (represents p1 and p3).
		ArrayList<Integer> allCombinationsResource = new ArrayList<Integer>();
		String[] lineElements = line.split("\t");
		
		for(int i=0; i<propertyQuantity; i++) {
			String element = lineElements[i];
			if(element.equals("t")) {
				allCombinationsResource.add(i+1);
			} else if(element.equals("f")) {
				
			} else {
				throw new GroupByPropertiesResultFileContentWrongException();
			}
		}
		ArrayList<ArrayList<Integer>> allCombinations = AllCombinations(allCombinationsResource);
		
		
		Iterator<ArrayList<Integer>> it = allCombinations.iterator();
		// One combination could generate a new/update an old Atom.
		int count = Integer.parseInt(lineElements[propertyQuantity].split(" ")[1]);
		while(it.hasNext()) {
			ArrayList<Property> propertyCombination = new ArrayList<Property>();
			ArrayList<Integer> oneCombination = it.next();
			for(Integer propertyNumber: oneCombination) {
				Property property = new Property(propertyNumber, propertiesShorterNames.get(propertyNumber-1));
				propertyCombination.add(property);
			}
			Atom atom = new Atom(propertyCombination, count);
			
			if(this.atoms.containsKey(propertyCombination.size())) {
				if(this.atoms.get(propertyCombination.size()).contains(atom)) {
					// Atoms in this level contains the atom (They have same propertyCombination).
					int position = this.atoms.get(propertyCombination.size()).indexOf(atom);
					int previousCount = this.atoms.get(propertyCombination.size()).get(position).getCount();
					this.atoms.get(propertyCombination.size()).get(position).setCount(previousCount + count);
				} else {
					this.atoms.get(propertyCombination.size()).add(atom);
				}
			} else {
				// There is no atom in this level.
				ArrayList<Atom> atomsOfOneLevel = new ArrayList<Atom>();
				atomsOfOneLevel.add(atom);
				atoms.put(propertyCombination.size(), atomsOfOneLevel);
			}
		}
	}
	
	
	private void linkAtoms() {
		// Starting from level 1 not level 0, because level has only 1 atom (all) and this atom has no parents.
		for(int i=1; i<atoms.size(); i++) {
			ArrayList<Atom> allAtomsOfOneLevel = atoms.get(i);
			for(Atom a: allAtomsOfOneLevel) {
				ArrayList<ArrayList<Integer>> potentialParentsNumbers = a.predictAllParents();
				for(ArrayList<Integer> parentNumbers: potentialParentsNumbers) {
					Atom targetAtomInParentsLevel = new Atom(parentNumbers);
					if(atoms.get(i-1).contains(targetAtomInParentsLevel)) {
						// targetAtom exists in the parents level.
						int position = atoms.get(i-1).indexOf(targetAtomInParentsLevel);
						Atom targetParentAtom = atoms.get(i-1).get(position);
//						System.out.println("child: " + a);
//						System.out.println("parent: " + targetParentAtom);
						// Parent links to child
						targetParentAtom.getChildren().add(a);
						// Child links to parent
						a.getParents().add(targetParentAtom);
					}
				}
			}
		}
	}
	
	private void initializePropertiesShorterNames() {
		for(String fullName: propertiesNames) {
			propertiesShorterNames.add(StatementGenerator.getShorterTypeName(fullName));
		}
	}
	
	/**
	 * INPUT example:	[1, 2, 3]
	 * OUTPUT example:	[[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]
	 */
	public static ArrayList<ArrayList<Integer>> AllCombinations(ArrayList<Integer> arr) {
        ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();
		int all = arr.size();
        int nbit = 1 << all;
        for (int i = 0; i < nbit; i++) {
        	ArrayList<Integer> oneCombination = new ArrayList<Integer>();
            StringBuffer sb = new StringBuffer();
            for (int j = 0; j < all; j++) {
                if ((i & (1 << j)) != 0) {
                    sb.append(arr.get(j));
                    oneCombination.add(arr.get(j));
                }
            }
            result.add(oneCombination);
        }
        return result;
	}
	
	
	public static void main(String[] args) throws GroupByPropertiesResultFileContentWrongException, FileNotFoundException, IOException {
		// TODO remove for test and the file
		//String filePath = exploratoryRDFAnalytics.GlobalSettings.GROUP_BY_PROPERTIES_RESULT_FILE_FOLDER_PATH + exploratoryRDFAnalytics.GlobalSettings.GROUP_BY_PROPERTIES_RESULT_FILE_NAME + "_for_test" + ".txt";
		String filePath = exploratoryRDFAnalytics.GlobalSettings.GROUP_BY_PROPERTIES_RESULT_FILE_FOLDER_PATH + exploratoryRDFAnalytics.GlobalSettings.GROUP_BY_PROPERTIES_RESULT_FILE_NAME + "_type_Article" + ".txt";
		Lattice la = new Lattice(filePath);
		//System.out.println(la);
		
		ArrayList<Integer> propertyCombinationNumbers = new ArrayList<Integer>(Arrays.asList(1, 25));
//		la.writeJSONFile("../d3/lattice_graph/lattice-data.json", new Atom(propertyCombinationNumbers));	 
		la.writeJSONFile("../d3/lattice_graph/lattice-data.json");
	}
	
}
